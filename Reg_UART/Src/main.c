/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include "stm32f411xe.h"

uint32_t SystemCoreClock = 100000000; //100MHz

int _write(int file, char *ptr, int len)
{
  int i=0;
  for(i=0 ; i<len ; i++)
    ITM_SendChar((*ptr++));

  return len;
}

char ch[] = {"HELLO\r\n"};
/*
 * 1.	In APH1 Enable USART Peripheral
 * 2.	Set PA9 to Tx PA10 to Rx
 */
int main(void)
{
    /* Loop forever */
	printf("Program Entry Point\r\n");

	//Enable GPIO Port A Clock
	SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIOAEN);

	// Set High Speed on PA9 and PA10
	MODIFY_REG(GPIOA->OSPEEDR,
			GPIO_OSPEEDR_OSPEED10 | GPIO_OSPEEDR_OSPEED9,
			_VAL2FLD(GPIO_OSPEEDR_OSPEED10,3) | _VAL2FLD(GPIO_OSPEEDR_OSPEED9,3)
			);

	//Set PA9 PA10 to AF Mode
	MODIFY_REG(GPIOA->MODER,
			GPIO_MODER_MODE10 | GPIO_MODER_MODE9,
			_VAL2FLD(GPIO_MODER_MODE10,2) | _VAL2FLD(GPIO_MODER_MODE9,2)
			);

	//Set PA9 and PA10 to UART_Tx and UART_Rx
	MODIFY_REG(GPIOA->AFR[1],
			GPIO_AFRH_AFSEL9 | GPIO_AFRH_AFSEL10,
			_VAL2FLD(GPIO_AFRH_AFSEL9,7) | _VAL2FLD(GPIO_AFRH_AFSEL10,7)
			);

	//Enable UART Peripheral Clock
	SET_BIT(RCC->APB2ENR,RCC_APB2ENR_USART1EN);

	//Set UART Baudrate
	MODIFY_REG(USART1->BRR,
			USART_BRR_DIV_Mantissa | USART_BRR_DIV_Fraction,
			_VAL2FLD(USART_BRR_DIV_Mantissa,54) | _VAL2FLD(USART_BRR_DIV_Fraction,4)
			);

	//Enable USART (UE) Transmitter (TE) Receiver (RE)
	SET_BIT(USART1->CR1,
			USART_CR1_UE | USART_CR1_TE | USART_CR1_RE);

	while(1){
		for(int i = 0; i < 7; i++){
			printf("Hello\r\n");
			//wait until Tx buff Empty
			while(!READ_BIT(USART1->SR,USART_SR_TXE));
			//Transfer Data to Tx buff
			USART1->DR = (uint8_t)(ch[i] & 0xFF);
			//wait until transmition complete
			while(!READ_BIT(USART1->SR,USART_SR_TC));
		}
		for(int i = 0;i<1000000;i++);
	}
}

void SystemInit(void) {

	//Enable PWR CLK
	SET_BIT(RCC->APB1ENR,RCC_APB1ENR_PWREN);

	//Set Regulator voltage scale mode for 100MHz
	MODIFY_REG(PWR->CR,
			PWR_CR_VOS,
			_VAL2FLD(PWR_CR_VOS,3));

	//Enable prefetch, Instruction cache, data cache
	SET_BIT(FLASH->ACR,
			FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN);

	//Set Flash Latency 3WS
	MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY,
			_VAL2FLD(FLASH_ACR_LATENCY,FLASH_ACR_LATENCY_3WS));

	//SET HSE Bypass
	SET_BIT(RCC->CR, RCC_CR_HSEBYP);
	//Enable HSE CLK
	SET_BIT(RCC->CR, RCC_CR_HSEON);
	//Wait for HSE to get stable
	while (!READ_BIT(RCC->CR, RCC_CR_HSERDY))
		;

	//Set PLL Prescaler values
	MODIFY_REG(RCC->PLLCFGR,
			RCC_PLLCFGR_PLLQ | RCC_PLLCFGR_PLLP | RCC_PLLCFGR_PLLN | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLSRC,
			_VAL2FLD(RCC_PLLCFGR_PLLM,4) | _VAL2FLD(RCC_PLLCFGR_PLLN,100) | _VAL2FLD(RCC_PLLCFGR_PLLP,0) | RCC_PLLCFGR_PLLSRC_HSE);
	//Enable PLL
	SET_BIT(RCC->CR, RCC_CR_PLLON);
	//Wait for PLL to get stable
	while (!READ_BIT(RCC->CR, RCC_CR_PLLRDY))
		;

	//Select System Clk as PLL
	MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, _VAL2FLD(RCC_CFGR_SW,RCC_CFGR_SW_PLL));


	//check status of system clk source
	while (READ_BIT(RCC->CFGR,RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL)
		;

	//Set APB1 Prescaler to div 2
	MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_CFGR_PPRE1_DIV2);

	//Disable HSI CLK
	CLEAR_BIT(RCC->CR, RCC_CR_HSION);
}
